## Что было сделано

### docker networks

 * Скачан образ joffotron/docker-net-tools
 * Запущен ifconfig в режиме network none
   * команда `make network_none` в каталоге `src`
   * Вывод показал наличие лупбэка и больше ничего
 * Запущен ifconfig в режиме network host
   * команда `make network_host` в каталоге `src`
   * Вывод показал все сетки, доступные на host-машине
 * Запущен nginx в режиме network host несколько раз
   * В течение какого-то времени вновь запущенный контейнер оставался активным, потом умирал, т.к. не мог получить в пользование порт

 * Задумался, как выполнить задание на docker-host, ведь его у меня нет
 * Запустил VM в VirtualBox, в ней - debian
 * Поставил на нём докеровские пакеты
 * Сделал `ln -s /var/run/docker/netns /var/run/netns` (почему-то мне кажется, что на локальной OS этого лучше не делать)
 * Запустил в отдельном окне внутри debian (на дополнительном мониторе, хвастаюсь) `watch "sudo ip netns"`.
   * Пока запускал nginx в сетке `host`, отличий не обнаружил, namespace оставался один - default.
   * Когда запустил несколько раз в `none`, увидел, что на каждый запуск приводит к появлению нового namespace. Например, так выглядел вывод `sudo ip netns` после двух запусков с `network none`
```
41b82aec2fd6
b3503bb5cd01
default
```
 * Ни с того ни с сего вспомнил, что неплохо бы перенести старые ворклоги в readme. И перенёс.

 * Начало следующей части задания было знакомо из `docker-2`, поэтому неудачный запуск bridge network пропустил
 * Успешный запуск можно посмотреть в `src/scripts/run.sh` или `src/scripts/run_env.sh`
 * Собрал запуск с раздельными сетями в `src/scripts/run_net.sh`
 * Список сетей полученных в проекте получил через `docker network ls | grep _net`:
```
ef5e35431b04   back_net    bridge    local
fdb8a7e79817   front_net   bridge    local
```
 * `brctl show` без указания id показывает полный список (вместе с интерфейсом смамого docker-а)
```
bridge name     bridge id               STP enabled     interfaces
br-ef5e35431b04         8000.02420b717a11       no
br-fdb8a7e79817         8000.02420d42b4d9       no
…
```
 * Посмотрел на вывод `iptables`. Понял мало, но поразился красоте. Поставил себе отметку «почитать про iptables на досуге». Выглядело это счастье так:
```
Chain POSTROUTING (policy ACCEPT)
target     prot opt source               destination
MASQUERADE  all  --  10.0.1.0/24          0.0.0.0/0
MASQUERADE  all  --  10.0.2.0/24          0.0.0.0/0
MASQUERADE  all  --  172.17.0.0/16        0.0.0.0/0
LIBVIRT_PRT  all  --  0.0.0.0/0            0.0.0.0/0
```
 * Ага, это было уже после того, как я убил все контейнеры. С поднятым приложением это выглядело чуть длиннее:
```
Chain POSTROUTING (policy ACCEPT)
target     prot opt source               destination
MASQUERADE  all  --  10.0.1.0/24          0.0.0.0/0
MASQUERADE  all  --  10.0.2.0/24          0.0.0.0/0
MASQUERADE  all  --  172.17.0.0/16        0.0.0.0/0
LIBVIRT_PRT  all  --  0.0.0.0/0            0.0.0.0/0
MASQUERADE  tcp  --  10.0.1.2             10.0.1.2             tcp dpt:9292
```
 * Обнаружил правило перенаправления по порту 9292 в цепочке DOCKER
 * `ps aux | grep docker-proxy | grep -v grep` выдало целых два процесса

### docker-compose
 * Собрал docker-compose.yml из примера в gist, в процессе закомментировал ключи `<sevicename>.build` (уже построено, зачем второй раз бегать)
 * Убил старый набор контейнеров, поднятый скриптом
 * Ещё раз почитал методичку, обнаружил конструкцию `export USERNAME=…`
 * Поднял `docker-compose up`
   * Обнаружил, что volume, созданный докером не втягивается
   * Зато созданный docker-compose остается живым между запусками
 * Посмотрел на `docker-compose ps`, обнаружил список запущенных контейнеров
   * Правда контейнер комментариев почему-то не был запущен
   * Поменял контейнер на собираемый из ubuntu и всё заработало
   * Похоже, что сборке kaineer/comment:2.0 чего-то не хватает
 * Настроил `src/.envrc` для запуска `docker-compose` с параметрами: имя пользователя, версии образов, порт, на котором нужно открывать страничку
 * Проверил, что вариант с `.env` тоже работает и принял это к сведенью
 * Добавил .env.example, вдруг его потребуют проверки?

 * Чтобы поменять базовое имя проекта достаточно указать переменную окружения `COMPOSE_PROJECT_NAME` как указано в `.env.example` :)

 * Поискал в PR предыдущего потока, как указать в docker-compose.override.yml команду для контейнера
 * Погуглил на предмет задания volume-ов из файловой системы для проектов
 * Решил, что пока хватит
